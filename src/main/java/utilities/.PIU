package utilities;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import models.Device;
import models.SubSystem;
import models.Vendor;
import parsers.LineParser;
import picocli.CommandLine;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.PriorityQueue;
import java.util.stream.Collectors;

import static parsers.LineParser.VendorModel.*;


@CommandLine.Command(name="piu", version="piu 1.0", mixinStandardHelpOptions = true)
public class PIU implements Runnable{

    @CommandLine.Parameters(index = "0", description = "This is the input pci.ids file")
    private File inputPCIidFile;

    @CommandLine.Parameters(index = "1", description = "This is the output pci.ids file")
    private File outputPCIidFile;

    @CommandLine.Option(names={"-v"}, description = "Override the vendor names of the pending entries")
    private boolean overrideVendors;

    @CommandLine.Option(names={"-d"}, description = "Override the device names of the pending entries")
    private boolean overrideDevices;

    @CommandLine.Option(names={"-s"}, description = "Override the subsystem names of the pending entries")
    private boolean overrideSubSystems;

    @CommandLine.ArgGroup(exclusive = true, multiplicity = "1")
    private Exclusive exclusive;

    static class Exclusive{
        @CommandLine.Option(names={"-f", "--file"}, required = true, description="Json formatted pci id entries")
        private File piuJSON = null;
        @CommandLine.Option(names={"-e", "--entry"}, required = true, description="single entry <ven:vname:dev:dname:sv:sd:sname>")
        private String piuEntry = null;
    }


    @Override
    public void run() {
        try {

            // Step 0 - open both files to be read and writen to/from
            BufferedReader in = new BufferedReader(new FileReader(inputPCIidFile));
            LineCountWriter out = new LineCountWriter(new FileWriter(outputPCIidFile));

            if(exclusive.piuEntry != null){
                // Case 1 - if no piu json input

            }else {
                // Case 2 - if there is a piu json input

                // Step 1 - Parse the json file
                Gson gson = new GsonBuilder().serializeNulls().create();
                PriorityQueue<Vendor>pendingVendors = gson.fromJson(new FileReader(exclusive.piuJSON),
                                                      new TypeToken<PriorityQueue<Vendor>>(){}.getType());
                // Step 2 - read each line
                update(pendingVendors, in, out);

            }

        }catch (Exception e){
            e.printStackTrace();
            System.out.println(e);
        }


    }
    // Guarenteed at least on que
    private void writePending(PriorityQueue<Vendor> pv, LineCountWriter writer, String line) throws Exception{
        // line parser is a singleton there it doesnt change
        LineParser lineParser = LineParser.getInstance();
        switch (lineParser.getType(line)) {
            case VENDOR_LINE: {
                Vendor currPending;
                int comp = CONTINUE;
                LineParser.VendorModel vendorModel = LineParser.getInstance().getModel();
                // While pv isnt empty and we can write
                while ((currPending=pv.peek()) != null && (comp = vendorModel.compareTo(currPending)) == WRITE) {
                    // Write the whole vendor
                    writer.write(currPending.toString());
                    // get rid of the vendor (pv.size() = pv.size() -1)
                    pv.poll();
                    System.out.println("new output at line " + writer.getLineNumber() + ": " + currPending);
                }
                // No more vendor (will never go to writePending
                if(currPending == null) {
                    writer.write(line + "\n");
                    // If the line is equal meaning only vendor line
                }else if(comp == EQUAL && overrideVendors){
                    writer.write(currPending.toLine());
                    pv.poll();
                }else{
                    writer.write(line + "\n");
                }
            }
            break;
            case DEVICE_LINE: {
                LineParser.VendorModel vendorModel = lineParser.getModel();
                int comp = 1;
                Vendor currVendor = pv.peek();
                Device currDevice = currVendor.getDevices().peek();

                while (currDevice != null && vendorModel.compareTo(currVendor) == WRITE) {
                    writer.write(currDevice.toString());
                    currVendor.getDevices().poll();
                    // Check if this vendor is empty after getting rid of device
                    if(currVendor.size() == 0){
                        pv.poll();
                    }
                    System.out.println("new output at line " + writer.getLineNumber() + ": " + currDevice);
                }

                // Case 1 - no more devices, thus vendor has a size() = 0
                if(comp == EQUAL && overrideVendors) {
                    writer.write(currVendor.getDevices().poll().toLine());
                    if(currVendor.size() == 0){
                        pv.poll();
                    }
                }else if(currVendor.size() == 0){
                    writer.write(line+"\n");
                }
            }
            break;
            case SUB_LINE: {
                LineParser.VendorModel vendorModel = lineParser.getModel();
                SubSystem currPending;
                Vendor currVendor = pv.peek(); // guarenteed
                Device currDevice = currVendor.getDevices().peek(); // not guarenteed
                SubSystem currSub = currDevice.getSubSystems().peek(); // not guarenteed

                int comp = LineParser.VendorModel.CONTINUE;
                int overRideSub = 1;
                while (currDevice != null && currSub != null && (comp = vendorModel.compareTo(currVendor)) == LineParser.VendorModel.WRITE) {
                    currSub = currDevice.getSubSystems().poll();
                    if (currDevice.size() == 0) {
                        currVendor.getDevices().poll();
                    }
                    if (currVendor.size() == 0) {
                        pv.poll();
                    }
                    writer.write(currSub.toString() + "\n");
                    System.out.println("new output at line " + writer.getLineNumber() + ": " + currSub);
                }
                // Case 1 - no more devices, thus vendor has a size() = 0
                if (comp == EQUAL && overrideVendors) {
                    writer.write(currVendor.getDevices().poll().toLine());

                } else if (comp == EQUAL){
                    currDevice.getSubSystems().poll();
                    if (currDevice.size() == 0) {
                        currVendor.getDevices().poll();
                    }
                    if (currVendor.size() == 0) {
                        pv.poll();
                    }
                }else if(currVendor.size() == 0){
                    writer.write(line+"\n");
                } else {
                    writer.write(line + "\n");
                }

            }
            break;
            case COMMENT_LINE: {

                writer.write(line);
                writer.newLine();

            }
            break;
            case BLANK_LINE: {
                writer.write(line);
                writer.newLine();

            }
            break;
            case INVALID_LINE: {
                System.out.println("invalid line: " + line);

            }

        }


}


    private void update(PriorityQueue<Vendor> pv, BufferedReader reader, LineCountWriter writer) throws Exception
    {
        LineParser lineParser = LineParser.getInstance();


        for(String line: reader.lines().collect(Collectors.toList())) {

            if (pv.isEmpty()) {
                writer.write(line);
            } else {
                // assumed pv isnt empty
                writePending(pv, writer, line);
            }

        }

    }
    public static void main(String [] args){

        int exitCode = new CommandLine(new PIU()).execute(args);
        System.exit(exitCode);
    }




}
